// The following directive is necessary to make the package coherent:

// +build ignore

// rcsgen is used to generate configuration preloaded from RCS
package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"go/format"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/tidwall/gjson"
)

type val struct {
	Key   string
	Value string
	typ   int
}

const (
	Null = iota
	Bool
	Array
	String
	Map
)

func sniffType(v string) int {
	switch {
	case v == "":
		return Null
	case v[0] == '[':
		return Array
	case v[0] == '{':
		return Map
	case v == "true" || v == "false":
		return Bool
	default:
		return String
	}
}

func inferGoType(i interface{}) (string, string) { // format String, type
	switch i.(type) {
	case string:
		return "%q", "string"
	case int:
		return "%d", "int"
	case float64:
		return "%0.0f", "float64"
	case []interface{}:
		v := i.([]interface{})
		// only infer type of the first value, won't compile if the types are different
		fs, t := inferGoType(v[0])
		fmts := []string{}
		for range v {
			fmts = append(fmts, fs)
		}
		return fmt.Sprintf("[%d]%s{%s}", len(v), t, strings.Join(fmts, ",")), fmt.Sprintf("[%d]%s", len(v), t)
	default:
		return "%q", "string"
	}
}

func formatStr(a string) string {
	return fmt.Sprintf("%q", a)
}

func formatMap(a string) (string, error) {
	var m map[string]interface{}
	err := json.Unmarshal([]byte(a), &m)
	if err != nil {
		return "", err
	}

	structFields := ""
	structValsFmt := ""
	structVals := []interface{}{}
	for k, v := range m {
		fmtStr, typ := inferGoType(v)
		structFields = structFields + "\n" + snakeName(k) + " " + typ
		structValsFmt = structValsFmt + "\n" + fmtStr + ","
		switch v.(type) {
		case []interface{}:
			structVals = append(structVals, v.([]interface{})...)
		default:
			structVals = append(structVals, v)
		}
	}

	x := fmt.Sprintf(`struct {
%s
}{
%s
}`, structFields, structValsFmt)
	return fmt.Sprintf(x, structVals...), nil
}

func formatArray(a string) string {
	return "[]interface{}{}" // todo
}

func gen(data []byte, path []string) ([]val, error) {
	v := []val{}

	b := string(body)
	for _, path := range paths {
		vname := snakeName(path)
		gres := gjson.Get(b, path)
		switch sniffType(gres.Raw) {
		case Map:
			s, err := formatMap(gres.Raw)
			if err != nil {
				return nil, err
			}
			v = append(v, val{vname, s, Map})
			continue
		case Array:
			v = append(v, val{vname, formatArray(gres.Str), Array})
		default:
			v = append(v, val{vname, formatStr(gres.Str), String})
		}
	}
	return v, nil
}

func snakeName(n string) string {
	ws := strings.Split(n, ".")
	if len(ws) == 1 {
		ws = strings.Split(n, "-")
	}
	if len(ws) == 1 {
		ws = strings.Split(n, "_")
	}

	for i, w := range ws {
		ws[i] = strings.Title(w)
	}
	return strings.Join(ws, "_")
}

func main() {
	pkg := flag.String("pkg", "main", "package of the generated file")
	output := flag.String("output", "configuration.go", "output path")
	url := flag.String("url", "", "HTTP url to get json")
	file := flag.String("file", "", "path to the json file")

	flag.Parse()
	jsonpath := strings.Split(strings.Join(flag.Args(), ""), ",")

	if !strings.HasSuffix(*output, ".go") {
		*output = filepath.Join(*output, "configuration.go")
	}

	f, err := os.Create(*output)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	var data []byte
	if *url != "" {
		r, err := http.Get(url)
		if err != nil {
			return nil, err
		}

		data, err = ioutil.ReadAll(r.Body)
		if err != nil {
			log.Fatal(err)
		}
	} else {
		data, err = ioutil.ReadFile(*file)
		if err != nil {
			log.Fatal(err)
		}
	}

	v, err := gen(data, jsonpath)
	if err != nil {
		log.Fatal(err)
	}

	var buf []byte
	b := bytes.NewBuffer(buf)
	packageTemplate.Execute(b, struct {
		PackageName string
		Values      []val
	}{
		PackageName: *pkg,
		Values:      c,
	})

	ab, err := format.Source(b.Bytes())
	if err != nil {
		log.Fatal(err)
	}
	if _, err = io.Copy(f, bytes.NewBuffer(ab)); err != nil {
		log.Fatal(err)
	}
}

var packageTemplate = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.
// This file was generated by rcsgen
// using data from RCS

package {{ printf "%s\n" .PackageName -}}
var (
{{- range .Values }}
	{{- .Key }} = {{ printf "%s\n" .Value -}}
{{- end }}
)
`))
